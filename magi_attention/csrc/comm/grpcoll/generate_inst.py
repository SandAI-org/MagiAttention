import math
import os
import re
from collections import namedtuple
from pathlib import Path

# ==========================================
# Configuration
# ==========================================

inst_dir = "magi_attention/csrc/comm/grpcoll/instantiations"
os.makedirs(inst_dir, exist_ok=True)

# Batch size controls the number of template instantiations per .cu file.
BATCH_SIZE = 12


# ==========================================
# C++ Argument Signatures (Constants)
# ==========================================

# Get the kernel directory
kernel_dir = Path(__file__).parent / "kernels"


def extract_function_params(file_name, func_name):
    """
    Extracts the parameter list of a specific function from a .cuh/.h file.
    Cleans up comments and formats the parameters into a multi-line string.
    """

    file_path = kernel_dir / file_name

    if not os.path.exists(file_path):
        return f"Error: {file_path} not found."

    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Search for the function name followed by an opening parenthesis
    # \b ensures we match the exact function name
    pattern = rf"\b{re.escape(func_name)}\b\s*\("
    match = re.search(pattern, content)

    if not match:
        return f"Error: Function '{func_name}' not found."

    # Use a counter to find the matching closing parenthesis
    # This handles nested parentheses like std::optional<T> correctly
    start_index = match.end()
    paren_count = 1
    current_index = start_index
    raw_params = ""

    while paren_count > 0 and current_index < len(content):
        char = content[current_index]
        if char == "(":
            paren_count += 1
        elif char == ")":
            paren_count -= 1

        if paren_count > 0:
            raw_params += char
        current_index += 1

    # Remove C-style block comments /* ... */
    raw_params = re.sub(r"/\*.*?\*/", "", raw_params, flags=re.DOTALL)
    # Remove C++-style line comments // ...
    raw_params = re.sub(r"//.*", "", raw_params)

    # Split by comma and clean up whitespace for each parameter
    param_list = raw_params.split(",")
    cleaned_params = []
    for p in param_list:
        p_clean = p.strip()
        if p_clean:
            # Flatten multiple spaces/newlines into a single space
            p_clean = " ".join(p_clean.split())
            cleaned_params.append(p_clean)

    return "    " + ",\n    ".join(cleaned_params)


INTRANODE_CAST_ARGS = extract_function_params("intranode.cuh", "launch_group_cast")

INTRANODE_REDUCE_ARGS = extract_function_params("intranode.cuh", "launch_group_reduce")

INTERNODE_CAST_ARGS = extract_function_params("internode.cuh", "launch_group_cast")

INTERNODE_REDUCE_ARGS = extract_function_params("internode.cuh", "launch_group_reduce")


# ==========================================
# Helper Functions
# ==========================================


def write_if_different(path: Path, content: str) -> bool:
    if path.exists():
        with open(path, "r") as f:
            if f.read() == content:
                return False
    else:
        path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)
    return True


def write_batched_file(category_name, file_index, headers, namespace, content_list):
    """Generates a single .cu file containing a batch of instantiations."""
    if not content_list:
        return

    filename = f"{category_name}_part{file_index}.cu"
    filepath = os.path.join(inst_dir, filename)

    print(f"Generating {filepath} ({len(content_list)} instantiations)...")

    content = ""

    # File Header
    content += "/**********************************************************************************\n"
    content += " * Copyright (c) 2025-2026 SandAI. All Rights Reserved.\n"
    content += " * Auto-generated by generate_inst.py (Batched Version)\n"
    content += " *********************************************************************************/\n\n"

    # Includes
    for h in headers:
        content += f'#include "{h}"\n'
    content += "\n"

    # Namespace Start
    content += f"namespace {namespace} {{\n\n"

    # Instantiations
    for c in content_list:
        content += f"{c}\n"

    # Namespace End
    content += f"}} // namespace {namespace}\n"

    write_if_different(Path(filepath), content)


def process_batch(category_name, headers, namespace, all_instantiations):
    """Splits collected instantiations into batches and writes them to files."""
    total_inst = len(all_instantiations)
    num_files = math.ceil(total_inst / BATCH_SIZE)

    for i in range(num_files):
        start_idx = i * BATCH_SIZE
        end_idx = min((i + 1) * BATCH_SIZE, total_inst)
        batch_content = all_instantiations[start_idx:end_idx]

        write_batched_file(category_name, i, headers, namespace, batch_content)


# ==========================================
# 1. Intranode Group Cast
# ==========================================

intranode_cast_ranks_warps = [
    (1, 24),
    (2, 24),
    (3, 24),
    (4, 24),
    (5, 20),
    (6, 24),
    (7, 21),
    (8, 24),
]
intranode_cast_data_groups = [1, 2, 3]

inst_list = []
for data_groups in intranode_cast_data_groups:
    for ranks, warps in intranode_cast_ranks_warps:
        tpl_sig = f"template void launch_group_cast<{data_groups}, {ranks}, {warps}>"
        inst_list.append(f"{tpl_sig}(\n{INTRANODE_CAST_ARGS}\n);")

process_batch(
    "intranode_cast",
    ["kernels/intranode.cuh"],
    "magi_attn_comm::grpcoll::intranode",
    inst_list,
)

# ==========================================
# 2. Intranode Group Reduce
# ==========================================

DtypeConfig = namedtuple(
    "DtypeConfig", ["dtype", "comm_dtype", "reduce_dtype", "suffix"]
)
dtypes = [
    DtypeConfig("nv_bfloat16", "nv_bfloat16", "float", "bf16"),
    DtypeConfig("half", "half", "float", "fp16"),
    DtypeConfig("float", "nv_bfloat16", "float", "fp32_bf16"),
    DtypeConfig("float", "half", "float", "fp32_fp16"),
    DtypeConfig("float", "float", "float", "fp32"),
    DtypeConfig("double", "double", "double", "fp64"),
]

intranode_reduce_ranks_warps = intranode_cast_ranks_warps
intranode_reduce_data_groups = [1, 2]
reduce_acc = [True, False]

inst_list = []
for dconfig in dtypes:
    for data_groups in intranode_reduce_data_groups:
        for ranks, warps in intranode_reduce_ranks_warps:
            for acc in reduce_acc:
                acc_str = "true" if acc else "false"
                tpl_sig = f"template void launch_group_reduce<{dconfig.dtype}, {dconfig.comm_dtype}, {dconfig.reduce_dtype}, {data_groups}, {ranks}, {warps}, {acc_str}>"  # noqa: E501
                inst_list.append(f"{tpl_sig}(\n{INTRANODE_REDUCE_ARGS}\n);")

process_batch(
    "intranode_reduce",
    ["kernels/intranode.cuh"],
    "magi_attn_comm::grpcoll::intranode",
    inst_list,
)

# ==========================================
# 3. Internode Group Cast
# ==========================================

internode_cast_rdma_ranks = [2, 4, 8, 16, 32]
internode_cast_data_groups = [1, 2, 3]

inst_list = []
for data_groups in internode_cast_data_groups:
    for rdma_ranks in internode_cast_rdma_ranks:
        tpl_sig = f"template void launch_group_cast<{data_groups}, {rdma_ranks}>"
        inst_list.append(f"{tpl_sig}(\n{INTERNODE_CAST_ARGS}\n);")

process_batch(
    "internode_cast",
    ["kernels/internode.cuh"],
    "magi_attn_comm::grpcoll::internode",
    inst_list,
)

# ==========================================
# 4. Internode Group Reduce
# ==========================================

internode_reduce_ranks_warps = [(2, 24), (4, 24), (8, 24), (16, 24), (32, 32)]
internode_reduce_data_groups = [1, 2]


def get_internode_reduce_configs(warps, reduce_dtype):
    """Determine head configurations and TMA stages based on warps and dtype."""
    configs = []
    # Config A: Small Head count
    heads_a = 48
    tma_a = 1 if warps > 24 else 2
    configs.append((heads_a, tma_a))

    # Config B: Large Head count (depends on precision)
    tma_b = 1
    if reduce_dtype == "double":
        heads_b = 86 if warps > 24 else 120
    else:
        heads_b = 128
    configs.append((heads_b, tma_b))

    return configs


inst_list = []
for dconfig in dtypes:
    for data_groups in internode_reduce_data_groups:
        for rdma_ranks, fwd_warps in internode_reduce_ranks_warps:
            valid_configs = get_internode_reduce_configs(
                fwd_warps, dconfig.reduce_dtype
            )

            for kMaxNumHeads, kNumTMAStages in valid_configs:
                tpl_sig = f"template void launch_group_reduce<{dconfig.dtype}, {dconfig.comm_dtype}, {dconfig.reduce_dtype}, {data_groups}, {rdma_ranks}, {kMaxNumHeads}, {fwd_warps}, {kNumTMAStages}>"  # noqa: E501
                inst_list.append(f"{tpl_sig}(\n{INTERNODE_REDUCE_ARGS}\n);")

process_batch(
    "internode_reduce",
    ["kernels/internode.cuh"],
    "magi_attn_comm::grpcoll::internode",
    inst_list,
)

print("Done generating batched files.")
